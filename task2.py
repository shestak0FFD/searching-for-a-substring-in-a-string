from math import sqrt
def is_prime(x): #проверка является ли число простым
    for i in range(2, x):
        if x % i == 0:
            return False
    return True


def pref_func(s, current): #алгоритм Кнута-Морриса-Пратта
    cur_s = current + '#' + s
    n = len(s)
    p = [0 for i in range(n)]
    for i in range(1, n):
        j = p[i - 1]
        while (j > 0 and cur_s[i] != cur_s[j]):
            j = p[j - 1]
        if (cur_s[i] == cur_s[j]):
            j += 1
        p[i] = j
    return p


a = []
size = 0
for i in range(2, 5000):
    if (is_prime(i)):
        size += 1
        a.append(i)
    if (size == 500):
        break
s = ""
for element in a:
    s += str(element)

#наивный алгоритм поиска подстроки в строке
d1 = dict()
for i in range(10, 100):
    for j in range(0, len(s)):
        if (j + 1 < len(s)):
            current = s[j] + s[j + 1]
            if (current == str(i)):
                if (current not in d1):
                    d1[current] = 1
                else:
                    d1[current] += 1
maxx1 = 0
for count in d1.values():
    maxx1 = max(maxx1, count)
answer1 = 0 #количество наиболее часто встречающихся двузначных чисел в образовавшейся строке
for count in d1.values():
    if (count == maxx1):
        answer1 += 1

#алгоритм Кнута-Морриса-Пратта
d2 = dict()
maxx2 = 0
for i in range(10, 100):
    p = pref_func(s, str(i))
    for count in p:
        if (count == 2):
            if (str(i) not in d2):
                d2[str(i)] = 1
            else:
                d2[str(i)] += 1
    maxx2 = max(maxx2, d2[str(i)])
answer2 = 0 #количество наиболее часто встречающихся двузначных чисел в образовавшейся строке
for count in d2.values():
    if (count == maxx2):
        answer2 += 1


#Анализ изученных алгоритмов поиска подстрок
#1. Наивный алгоритм: самая простая реализация и идея, не требует доп. памяти,
# но намного медленнее чем все остальные алгоритмы

#2. Алгоритм Кнута-Морриса-Пратта: алгоритм позволяет оптимизировать поиск подстроки, избегая повторных сравнений,
# но этот алгоритм требует предварительную обработку и занимает доп. память для хранения префиксной функции.

#3. Алгоритм Бойера-Мура: использует стратегию сдвига шаблона и предварительно вычисленные таблицы сдвигов для каждого
# символа в образце. Работает в среднем чуть быстрее или с такой же скоростью как Кнута-Морриса-Пратта, но
# требует больше памяти для хранения таблицы сдвигов.

#4. Алгоритм Рабина-Карпа: использует хэш-функцию для быстрого сравнения подстроки с шаблоном. Этот алгоритм имеет
# линейную сложность, также как и алгоритм Кнута-Морриса-Пратта и алгоритм Бойера-Мура, но может давать ложные совпадения из-за коллизий хэш-функции.
